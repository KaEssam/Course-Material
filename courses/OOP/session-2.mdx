---
title: 'Session 2 - Class Members & Encapsulation'
tags: ['Fields', 'Properties', 'Constructors', 'Methods']
---

## 1. Fields vs Properties

**Fields** are variables that store data directly:

```csharp

public class Book

{

Â  Â  public string title; // Field - direct access, no protection

}

```

**Properties** provide controlled access to data:

```csharp

public class Book

{

Â  Â  private string _title; // Private field - protected storage
Â  Â  public string Title Â  Â // Property - controlled access

Â  Â  {
Â  Â  Â  Â  get { return _title; }
Â  Â  Â  Â  set

Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  if (string.IsNullOrWhiteSpace(value))
Â  Â  Â  Â  Â  Â  Â  Â  throw new ArgumentException("Title cannot be empty");
Â  Â  Â  Â  Â  Â  _title = value.Trim();
Â  Â  Â  Â  }
Â  Â  }
}

```

### Key Benefits of Properties

- **Validation**: Prevent invalid data
- **Processing**: Clean and format data
- **Computed Values**: Calculate values on-the-fly
- **Future-Proofing**: Can add logic later without breaking code

---

## 2. Access Modifiers

| Modifier    | Visibility                 | Usage                          |
| ----------- | -------------------------- | ------------------------------ |
| `private`   | Only within the same class | Internal data, helper methods  |
| `protected` | Class and derived classes  | Inheritance scenarios          |
| `internal`  | Same assembly/project      | Framework/library internal use |
| `public`    | Everywhere                 | Public interface of your class |

### Example

```csharp

public class Book

{
Â  Â  // Private fields - only this class can access
Â  Â  private string _title;
Â  Â  private string _author;

Â  Â  // Public properties - external code can access
Â  Â  public string Title { get; set; }
Â  Â  public string Author { get; set; }

Â  Â  // Private methods - internal helper logic
Â  Â  private string FormatName(string name) { ... }

Â  Â  // Public methods - class functionality
Â  Â  public void DisplayInfo() { ... }

}

```

---

## 3. Constants and Readonly

**Constants** - Compile-time values, shared across all instances:

```csharp

public const int MAX_BORROWED_BOOKS = 3;
public const string DEFAULT_USER_TYPE = "Standard";

```

**Readonly** - Runtime values, set once per instance:

```csharp

public readonly int UserId;
public readonly DateTime AccountCreatedDate;



public User()

{
Â  Â  UserId = GenerateUserId(); Â  Â  Â  Â // Set in constructor
Â  Â  AccountCreatedDate = DateTime.Now; // Different for each user
}

```

**Static Readonly** - Runtime values, same for all instances:

```csharp
public static readonly string LibraryBranch = "Main Branch";
```

### When to Use What?

- **`const`**: Mathematical constants, configuration values that never change
- **`readonly`**: Instance-specific values set at creation (IDs, timestamps)
- **`static readonly`**: Class-wide values that might be computed at runtime

---

## 4. Properties

### Property Types

#### Full Properties (with backing fields)

```csharp

private string _title;

public string Title

{
Â  Â  get { return _title; }
Â  Â  set
Â  Â  {

Â  Â  Â  Â  if (string.IsNullOrWhiteSpace(value))
Â  Â  Â  Â  Â  Â  throw new ArgumentException("Title cannot be empty");
Â  Â  Â  Â  _title = value.Trim();

Â  Â  }
}

```

#### Auto-Properties

```csharp
public string Publisher { get; set; } = "Unknown Publisher";
public bool IsActive { get; set; } = true;

```

#### Read-Only Properties

```csharp
public string SecurityCode { get; } // Can only be set in constructor

public bool IsAvailable => _availableCopies > 0; // Computed property

```

#### Private Setters

```csharp

public int BorrowedBooks { get; private set; } // Only class can modify

```

### Computed Properties

Properties that calculate their values:

```csharp

public bool CanBorrow => BorrowedBooks < MAX_BORROWED_BOOKS;

public int AvailableBorrowSlots => MAX_BORROWED_BOOKS - BorrowedBooks;

public bool IsNewRelease => DateTime.Now.Subtract(PublishedDate).Days <= 365;

```

---

## 5. Constructors

### Default Constructor

A constructor with **no parameters** that provides default values for all fields.

```csharp

public Book()

{
Â  Â  Title = "Unknown Title";
Â  Â  Author = "Unknown Author";
Â  Â  ISBN = "0000000000";
Â  Â  AvailableCopies = 0;

}

```

#### **Key Points**:

- **Automatic**: If you don't define ANY constructor, C# provides a default one
- **Explicit**: You can define your own with custom initialization
- **Validation**: Still goes through property setters if you use them

### Parameterized Constructor

Multiple Parameter Combinations

```csharp

public Book(string title, string author, string isbn, int availableCopies)

{

Â  Â  Title = title; Â  Â  Â  Â  Â  // Uses property validation

Â  Â  Author = author;

Â  Â  ISBN = isbn;

Â  Â  AvailableCopies = availableCopies;

}

```

### Constructor Chaining

#### Using `this()` to Chain Constructors

Constructor chaining allows one constructor to call another, reducing code duplication.

```csharp

public class Book

{
Â  Â  /// QUICK CONSTRUCTOR - Single copy default
Â  Â  /// Chains to the 4-parameter constructor with defaulted copies
Â  Â  public Book(string title, string author, string isbn)
Â  Â  Â  Â  : this(title, author, isbn, 1) // Calls 4-parameter constructor

Â  Â  {
Â  Â  Â  Â  Console.WriteLine("ğŸ”§ Quick Constructor called (chaining to 4-parameter)");
Â  Â  Â  Â  // Additional initialization can go here if needed

Â  Â  }


Â  Â  /// CONDITIONAL CONSTRUCTOR - Popular books get more copies
Â  Â  /// Chains with conditional logic

Â  Â  public Book(string title, string author, string isbn, bool isPopular)

Â  Â  Â  Â  : this(title, author, isbn, isPopular ? 5 : 1) // Conditional chaining

Â  Â  {

Â  Â  Â  Â  Console.WriteLine($"ğŸ”§ Conditional Constructor called (Popular: {isPopular})");

Â  Â  }




Â  Â /// EXTENDED CONSTRUCTOR - Chains to basic, then adds more

Â  Â  public Book(string title, string author, string isbn, int availableCopies, DateTime publishedDate)

Â  Â  Â  Â  : this(title, author, isbn, availableCopies) // Chain to basic constructor

Â  Â  {
Â  Â  Â  Â  Console.WriteLine("ğŸ”§ Extended Constructor called (with chaining)");


Â  Â  Â  Â  // Override the default date with provided date
Â  Â  Â  Â  PublishedDate = publishedDate;

Â  Â  }




Â /// FULL CONSTRUCTOR - Chains and then sets additional properties
Â  Â  public Book(string title, string author, string isbn, int availableCopies,

Â  Â  Â  Â  Â  Â  Â  Â DateTime publishedDate, string publisher, string genre, decimal price)

Â  Â  Â  Â  : this(title, author, isbn, availableCopies, publishedDate) // Chain to extended

Â  Â  {

Â  Â  Â  Â  Console.WriteLine("ğŸ”§ Full Constructor called (final in chain)");



Â  Â  Â  Â  // Set the additional properties
Â  Â  Â  Â  Publisher = publisher;
Â  Â  Â  Â  Genre = genre;
Â  Â  Â  Â  Price = price;

Â  Â  }

}

```

#### Chaining Benefits:

- **DRY Principle**: Don't Repeat Yourself
- **Centralized Logic**: Main initialization in one place
- **Easier Maintenance**: Changes in one constructor affect all
- **Clear Intent**: Shows relationship between constructors

### 5. Copy Constructor

##### Creating Objects from Existing Objects

C# doesn't have built-in copy constructors like C++, but we can create our own.

````csharp

public class Book

{

Â 

Â  Â  /// COPY CONSTRUCTOR - Creates new book from existing one
Â  Â  /// Called when: new Book(existingBook)
Â  Â  /// Creates a separate, independent object with same values

Â  Â  public Book(Book originalBook)

Â  Â  {

Â  Â  Â  Â  Console.WriteLine("ğŸ”§ Copy Constructor called");
Â  Â  Â  Â  if (originalBook == null)
Â  Â  Â  Â  Â  Â  throw new ArgumentNullException(nameof(originalBook), "Cannot copy from null book");


Â  Â  Â  Â  // Generate NEW readonly fields (this is a new object)
Â  Â  Â  Â  BookId = GenerateBookId(); Â  Â  Â // New ID
Â  Â  Â  Â  CreatedDate = DateTime.Now; Â  Â  // New creation time
Â  Â  Â  Â  Barcode = GenerateBarcode(); Â  Â // New barcode
Â  Â  Â  Â  // Copy all properties from original book
Â  Â  Â  Â  Title = originalBook.Title;
Â  Â  Â  Â  Author = originalBook.Author;
Â  Â  Â  Â  ISBN = originalBook.ISBN;
Â  Â  Â  Â  AvailableCopies = originalBook.AvailableCopies;
Â  Â  Â  Â  PublishedDate = originalBook.PublishedDate;
Â  Â  Â  Â  Publisher = originalBook.Publisher;
Â  Â  Â  Â  Genre = originalBook.Genre;
Â  Â  Â  Â  Price = originalBook.Price;
Â  Â  Â  Â  // Update static counters
Â  Â  Â  Â  _totalBooksCreated++;
Â  Â  Â  Â  UpdateBookCounts();

Â  Â  }
Â  Â  ```
Â  Â 
Â 
#### Copy Constructor Use Cases

- **Backup/Snapshot**: Create backup before modifications
- **Template Objects**: Create similar objects from templates
- **Undo/Redo**: Store object states for undo functionality
- **Parallel Processing**: Create independent copies for threads

### Static Constructor

A **static constructor** is called automatically **ONCE** when the class is first accessed. It has no access modifiers, no parameters, and cannot be called directly.

```csharp

public class Book

{

Â  Â  // Static fields
Â  Â  public static readonly string LibraryName;
Â  Â  private static int _totalBooksCreated = 0;


Â  Â  /// STATIC CONSTRUCTOR - Runs once when class is first accessed
Â  Â  /// - No access modifier (not public, private, etc.)
Â  Â  /// - No parameters allowed
Â  Â  /// - Cannot be called directly
Â  Â  /// - Automatically called before first instance creation or static member access

Â  Â  static Book()

Â  Â  {

Â  Â  Â  Â  Console.WriteLine("ğŸ“š Static Constructor: Initializing Book class...");

Â  Â  Â  Â  // Initialize static readonly fields
Â  Â  Â  Â  LibraryName = "Central City Library";
Â  Â  Â  Â  // Perform one-time setup

Â  Â  Â  Â  Console.WriteLine($"Library Name set to: {LibraryName}");
Â  Â  Â  Â  // Could load configuration, initialize databases, etc.
Â  Â  Â  Â  LoadBookConfiguration();
Â  Â  }



Â  Â  private static void LoadBookConfiguration()

Â  Â  {
Â  Â  Â  Â  // Simulate loading configuration
Â  Â  Â  Â  Console.WriteLine("Loading book configuration...");

Â  Â  }

}

````

#### Use Static Constructor For:

- **One-time initialization** of static fields
- **Loading configuration** from files/databases
- **Initializing static collections** or caches
- **Setting up logging** or debugging
- **Registering types** in frameworks

### Constructor Best Practices

1. **Use properties in constructors** - Gets validation automatically
2. **Chain constructors** - Reduces code duplication
3. **Initialize readonly fields** - Must be done in constructor
4. **Validate parameters** - Fail fast with meaningful errors

---

## 6. Methods

### Method Types

#### Public Methods

```csharp

public void DisplayInfo() Â  Â  Â  Â  Â  // Shows object state
public bool BorrowBook() Â  Â  Â  Â  Â  // Business logic
public void UpdateContactInfo() Â  Â // Modify object

```

#### Private Methods (Helper Logic)

```csharp

private string FormatName(string name) Â  Â  Â // Data processing
private bool IsValidEmail(string email) Â  Â // Validation
private static int GenerateUserId() Â  Â  Â  Â // Utility function

```

#### Static Methods (Class-Level Behavior)

```csharp

public static bool AreEqual(Book book1, Book book2)
public static void GetLibraryInfo()

```

### Method Design Principles

1. **Single Responsibility** - Each method does one thing
2. **Meaningful Names** - Clear what the method does
3. **Return Values** - Indicate success/failure
4. **Validation** - Check parameters and state
5. **Error Handling** - Provide meaningful error messages

---

## 7. What C# Does Better

### C# Encapsulation Advantages

#### 1. **Properties Instead of Get/Set Methods**

```csharp

// Java style (verbose)
book.setTitle("Clean Code");
String title = book.getTitle()


// C# style (clean)
book.Title = "Clean Code";
string title = book.Title;

```

#### 2. **Auto-Properties**

```csharp

// No need for backing fields for simple properties
public string Publisher { get; set; }
public decimal Price { get; set; } = 0.0m;

```

#### 3. **Expression-Bodied Members**

```csharp

// Concise computed properties
public bool IsAvailable => _availableCopies > 0;

public int BookAge => DateTime.Now.Year - _publishedDate.Year;

```

#### 4. **Nullable Types**

```csharp

public DateTime? LastLoginDate { get; set; } // Can be null

```

#### 5. **Property Initializers**

```csharp

public string UserType { get; set; } = "Standard"; // Default value

```

#### 6. **Private Setters**

```csharp

public int BorrowedBooks { get; private set; } // External read, internal write

```

#### 7. **Constructor Chaining**

```csharp

public User(string name, string email) : this() // Chain to default constructor

```

#### 8. **Object Initializers**

```csharp

var book = new Book("Title", "Author", "ISBN")

{
Â  Â  Publisher = "Publisher",
Â  Â  Genre = "Fiction",
Â  Â  Price = 29.99m

};

```

---

## 8. Best Practices

### âœ… Do

1. \*\*Always use properties for public data access

```csharp

public string Title { get; set; } // Good

public string title; Â  Â  Â  Â  Â  Â  Â // Bad

```

2. **Validate in property setters**

```csharp

set

{

if (string.IsNullOrWhiteSpace(value))

throw new ArgumentException("Title cannot be empty");

\_title = value.Trim();

}

```

3. **Use readonly for immutable data**

```csharp

public readonly int BookId;

```

4. **Use const for true constants**

```csharp

public const int MAX_BOOKS = 3;

```

5. **Make helper methods private**

```csharp

private string FormatName(string name) { ... }

```

6. **Use constructor chaining**

```csharp

public Book(string title) : this(title, "Unknown", "0000000000") { }

```

### âŒ Don

1. **Don't expose fields directly**

```csharp

public string \_title; // Bad - private field exposed

```

2. **Don't skip validation**

```csharp

set { \_title = value; } // Bad - no validation

```

3. **Don't make everything public**

```csharp

public string FormatName() // Bad - helper should be private

```

4. **Don't repeat validation logic**

```csharp

// Bad - duplicate validation in multiple constructors

// Good - use constructor chaining

```
