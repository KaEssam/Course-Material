---
title: 'Database Systems and ER Modeling'
---

# Database Design Fundamentals

## A Comprehensive Guide to Database Systems and Entity-Relationship Modeling

### Table of Contents

1. Types of Systems
2. Database Fundamentals
3. Database Life Cycle
4. Entity-Relationship Modeling
5. Keys in Database Design
6. Mapping ER Model to Relational Model

---

## Types of Systems

- **File-Based Systems**
- **SQL Database Systems (Relational)**
- **NoSQL Database Systems (Non-Relational)**

---

## Comparison Table

| Feature/Aspect           | **File-Based System**                             | **SQL DB System** (Relational)                      | **NoSQL DB System** (Non-Relational)                                           |
| ------------------------ | ------------------------------------------------- | --------------------------------------------------- | ------------------------------------------------------------------------------ |
| **File Structure**       | â€¢ Delimited Files (CSV, etc.) â€¢ Fixed Width Files | â€¢ Tables stored in `.mdf`, `.ldf` files             | â€¢ JSON/BSON (MongoDB) â€¢ Key-Value (Redis) â€¢ Column (Cassandra) â€¢ Graph (Neo4j) |
| **Redundancy**           | High                                              | Controlled via Normalization                        | Lower due to schema flexibility                                                |
| **Relationships**        | Not Supported                                     | Strong (via foreign keys)                           | Weak or application-enforced                                                   |
| **Constraints / Rules**  | Not Enforced (manual)                             | Enforced via schema (PK, FK, UNIQUE, etc.)          | Not enforced strictly (optional)                                               |
| **Search Performance**   | Slow (File Scan)                                  | Fast (Indexed Search)                               | Fast (especially for large distributed data)                                   |
| **Data Integrity**       | None                                              | High (via constraints, transactions)                | Limited (eventual consistency in many cases)                                   |
| **Security**             | Manual / External                                 | Built-in (roles, encryption, etc.)                  | Varies by DB, often manual or plugin-based                                     |
| **Backup / Restore**     | Manual                                            | Built-in tools available                            | Depends on DBMS; often requires tools or replication                           |
| **Sharing**              | Difficult                                         | Easy via DBMS                                       | Easy with distributed systems                                                  |
| **Data Types / Quality** | No enforcement                                    | Strict data types (ensures quality)                 | Flexible schemas; quality depends on application logic                         |
| **Development Time**     | Long                                              | Moderate (based on schema design)                   | Faster prototyping, especially for unstructured data                           |
| **Standard Language**    | None                                              | SQL (Structured Query Language)                     | No standard language; varies (MongoQL, CQL, etc.)                              |
| **Integration**          | Hard to integrate                                 | High integration support (via ODBC, APIs)           | High integration via APIs, microservices                                       |
| **File Format**          | Incompatible                                      | Compatible across DBMS (with migration tools)       | Often proprietary or semi-standard (e.g. BSON)                                 |
| **Expertise Needed**     | Low (but limited features)                        | Requires DBAs or SQL knowledge                      | Requires specific NoSQL knowledge per DB type                                  |
| **Cost**                 | Free                                              | Often expensive (licenses, server)                  | Many open-source and scalable options                                          |
| **Scalability**          | Not scalable                                      | Scales vertically (more powerful hardware)          | Scales horizontally (across many servers)                                      |
| **Best Use Case**        | Very simple data storage                          | Structured data with relationships and strict rules | Big data, real-time analytics, flexible/unstructured or evolving data          |

---

## Summary

| System Type | Best For                               | Limitations                                      |
| ----------- | -------------------------------------- | ------------------------------------------------ |
| File-Based  | Simple storage and legacy systems      | No integrity, security, or advanced features     |
| SQL         | Business apps needing strong structure | More setup, cost, and technical knowledge needed |
| NoSQL       | Scalable, fast, flexible systems       | Less strict data validation, varied tools        |

---

## Notes

- NoSQL is not a replacement for SQL â€” it's a different approach for different use cases.
- SQL is still dominant in many enterprise environments due to its structure and maturity.
- Choosing between them depends on **use case**, **data structure**, **scalability needs**, and **team expertise**.

---

## Database Fundamentals

## What is a Database?

A database is an organized collection of structured information or data, typically stored electronically in a computer system. It is managed by a Database Management System (DBMS), which provides:

- **Data Storage**: Efficient storage and organization of large amounts of data
- **Data Retrieval**: Quick access to specific information
- **Data Integrity**: Ensures accuracy and consistency of data
- **Data Security**: Controls access and protects sensitive information
- **Concurrent Access**: Multiple users can access data simultaneously

## Why Use Databases?

- **Eliminate Data Redundancy**: Avoid duplicate data storage
- **Data Consistency**: Ensure all data is accurate and up-to-date
- **Data Sharing**: Multiple applications can access the same data
- **Data Security**: Implement access controls and encryption
- **Backup and Recovery**: Protect against data loss

---

## Database Life Cycle

## 1. Requirements Gathering

- **Identify stakeholders** and their data needs
- **Document business rules** and constraints
- **Define functional requirements** (what the system should do)
- **Determine non-functional requirements** (performance, security)

## 2. DBMS Selection

- **Evaluate different database systems** (SQL Server, MySQL, PostgreSQL, Oracle, etc.)
- **Consider scalability, cost, and licensing**
- **Assess technical requirements** and compatibility

## 3. Analysis

- **Create conceptual models** using ER diagrams
- **Identify entities, attributes, and relationships**
- **Validate requirements** with stakeholders

## 4. Logical Design

- **Convert ER model to relational schema**
- **Define tables, columns, and relationships**
- **Apply normalization principles**

## 5. Physical Design

- **Optimize for performance** (indexes, partitioning)
- **Define storage structures**
- **Plan for security implementation**

## 6. Creation

- **Implement the database schema**
- **Create tables, views, and stored procedures**
- **Set up security and access controls**

---

## Entity-Relationship Modeling

### What is ER Modeling?

Entity-Relationship (ER) modeling is a conceptual design technique used to model data requirements of an information system. It provides a visual representation of entities, their attributes, and relationships between them.

### Importance and Benefits

- **Visual Communication**: Easy to understand and communicate with stakeholders
- **Design Validation**: Helps identify missing requirements early
- **Documentation**: Serves as comprehensive system documentation
- **Implementation Guide**: Provides blueprint for database creation
- **Maintenance**: Facilitates future modifications and updates

> ðŸ’¡ **Tip**: ER diagrams are like architectural blueprints for databases - they show the structure before building begins.

### Basic Components of ER Modeling

#### 1. Entities

An entity is a real-world object or concept.

**Strong Entities**: Can exist independently

- Student, Course, Department

**Weak Entities**: Cannot exist without another entity

- Dependent (requires Employee), Room (requires Building)

#### 2. Attributes

Properties that describe entities.

**Simple Attributes**: Cannot be divided further

- Name, Age, Email

**Composite Attributes**: Can be broken into smaller parts

- Address (Street, City, State, ZIP)

**Derived Attributes**: Calculated from other attributes

- Age (derived from birth_date)

**Multivalued Attributes**: Can have multiple values

- Phone numbers

**Complex Attributes**: Composite + multivalued (have more address and address is composite)

#### 3. Relationships

Associations between two or more entities.

#### Types (Degree) of Relationships:

1. **Unary (Degree = 1)**: Between two instances of one entity type

   - Example: Employee supervises Employee

2. **Binary (Degree = 2)**: Between two instances of two entity types

   - Example: Student enrolls in Course

3. **Ternary (Degree = 3)**: Among the instances of three entity types
   - Example: Student, Course, and Instructor in a Teaching relationship

#### Cardinality of Relationship

How many instances of one entity will or must be connected to a single instance from the other entities.

**One-to-One (1:1)**: Each entity instance relates to exactly one instance of another entity

- Example: Person has one Passport

**One-to-Many (1:N)**: One entity instance relates to many instances of another entity

- Example: Department has many Employees

**Many-to-Many (M:N)**: Many instances of one entity relate to many instances of another entity

- Example: Students enroll in multiple Courses

### Participation & Cardinality

**Cardinality**: Specifies the number of instances of one entity that can be associated with instances of another entity.

- Cardinality â†’ Maximum (1 or many)
- Participation â†’ Minimum (0 or 1)

- **Total Participation**: Every entity instance must participate in the relationship
- **Partial Participation**: Entity instances may or may not participate

---

## Keys in Database Design

Keys are crucial for maintaining data integrity and establishing relationships between tables.

### Types of Keys

#### 1. Primary Key (PK)

Uniquely identifies each record in a table. Cannot be NULL and must be unique.

#### 2. Foreign Key (FK)

References the primary key of another table, establishing relationships.

#### 3. Composite Key

Combination of two or more columns that uniquely identify a record.

#### 4. Candidate Key

Any column or combination of columns that can serve as a primary key.

#### 5. Super Key

A set of attributes that can uniquely identify a record (may include unnecessary attributes).

#### 6. Alternate Key

Candidate keys that are not chosen as the primary key.

#### 7. Surrogate Key

An artificial key used when no natural primary key exists.

---

## Mapping ER Model to Relational Model

Converting an ER diagram to a relational database schema involves specific rules and steps.

## Case Study: Company System

A big company has decided to store information about its projects and employees in a database.

### Requirements:

- The company has a number of employees. Each employee has SSN, Birth Date, Gender and Name which represented as Fname and Lname.
- The company has a set of departments. Each department has a set of attributes: DName, DNUM (unique) and locations.
- Employees work in several projects. Each project has Pname, PNumber as an identifier, Location City.
- Each employee may have a set of dependents. Each dependent has Dependent Name (unique), Gender and Birthdate. Note: if the employee left the company no need to store his dependents info.
- For each Department, there is always one employee assigned to manage that Department and each manager has a hiring Date.
- Department may have employees but employee must work on Only One department.
- Each department may have a set of projects and each project must be assigned to one department.
- Employees work in several projects and each project has several employees and each employee has a number of working hours in each project.
- Each employee has a supervisor.

### Mapping Rules Applied:

#### 1. Strong Entities â†’ Tables

- **Employee** â†’ Employee Table
- **Department** â†’ Department Table
- **Project** â†’ Project Table

#### 2. Weak Entities â†’ Tables with Composite Keys

- **Dependent** â†’ Dependent Table (with Employee SSN + Dependent Name as composite key)

#### 3. Relationships â†’ Foreign Keys or Junction Tables

**One-to-Many Relationships:**

- Department manages Projects â†’ Project table gets DepartmentID foreign key
- Employee works for Department â†’ Employee table gets DepartmentID foreign key
- Employee supervises Employee â†’ Employee table gets SupervisorSSN foreign key

**Many-to-Many Relationships:**

- Employee works on Projects â†’ Create WorksOn junction table with (EmployeeSSN, ProjectNumber, Hours)

#### 4. Sample Schema:

```sql
-- Employee Table
CREATE TABLE Employee (
    SSN VARCHAR(11) PRIMARY KEY,
    FName VARCHAR(50),
    LName VARCHAR(50),
    BirthDate DATE,
    Gender CHAR(1),
    DepartmentID INT,
    SupervisorSSN VARCHAR(11),
    FOREIGN KEY (DepartmentID) REFERENCES Department(DNUM),
    FOREIGN KEY (SupervisorSSN) REFERENCES Employee(SSN)
);

-- Department Table
CREATE TABLE Department (
    DNUM INT PRIMARY KEY,
    DName VARCHAR(100),
    Location VARCHAR(100),
    ManagerSSN VARCHAR(11),
    HiringDate DATE,
    FOREIGN KEY (ManagerSSN) REFERENCES Employee(SSN)
);

-- Project Table
CREATE TABLE Project (
    PNumber INT PRIMARY KEY,
    PName VARCHAR(100),
    LocationCity VARCHAR(100),
    DepartmentID INT,
    FOREIGN KEY (DepartmentID) REFERENCES Department(DNUM)
);

-- Dependent Table (Weak Entity)
CREATE TABLE Dependent (
    EmployeeSSN VARCHAR(11),
    DependentName VARCHAR(50),
    Gender CHAR(1),
    BirthDate DATE,
    PRIMARY KEY (EmployeeSSN, DependentName),
    FOREIGN KEY (EmployeeSSN) REFERENCES Employee(SSN) ON DELETE CASCADE
);

-- WorksOn Junction Table (Many-to-Many)
CREATE TABLE WorksOn (
    EmployeeSSN VARCHAR(11),
    ProjectNumber INT,
    Hours DECIMAL(4,1),
    PRIMARY KEY (EmployeeSSN, ProjectNumber),
    FOREIGN KEY (EmployeeSSN) REFERENCES Employee(SSN),
    FOREIGN KEY (ProjectNumber) REFERENCES Project(PNumber)
);
```

### Key Design Decisions:

1. **Weak Entity Handling**: Dependent table uses CASCADE DELETE to ensure dependents are removed when employee leaves
2. **Circular Reference**: Employee-Department management relationship handled with careful foreign key design
3. **Many-to-Many Resolution**: WorksOn table captures the relationship between employees and projects with additional attribute (hours)
4. **Supervisor Relationship**: Self-referencing foreign key in Employee table

---

## Summary

This comprehensive guide covers the fundamental concepts of database design, from understanding different types of systems to implementing complex ER models. The Company System case study demonstrates practical application of these concepts in a real-world scenario.

### Key Takeaways:

- **System Selection**: Choose the right database type based on your specific requirements
- **ER Modeling**: Essential for visualizing and planning database structure
- **Proper Key Design**: Critical for data integrity and relationships
- **Systematic Mapping**: Follow established rules when converting ER models to relational schemas

Understanding these fundamentals provides a solid foundation for designing efficient, maintainable database systems.
